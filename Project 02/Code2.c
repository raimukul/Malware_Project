#include <stdio.h>
#include <Windows.h>

int main(int argc, char* argv[]) {
    if (argc != 2) {
        printf("Usage: %s <filename>\n", argv[0]);
        return 1;
    }

    // Step 1: Open the file.
    HANDLE hFile = CreateFileA(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        printf("Error: Unable to open file %s\n", argv[1]);
        return 1;
    }

    // Step 2: Read the contents of the file into memory.
    DWORD dwFileSize = GetFileSize(hFile, NULL);
    LPBYTE lpFileBuffer = (LPBYTE) malloc(dwFileSize);
    if (!ReadFile(hFile, lpFileBuffer, dwFileSize, NULL, NULL)) {
        printf("Error: Unable to read file %s\n", argv[1]);
        CloseHandle(hFile);
        free(lpFileBuffer);
        return 1;
    }

    // Step 3: Verify that the file is a valid PE file.
    if (memcmp(lpFileBuffer, "MZ", 2) != 0) {
        printf("Error: File %s is not a valid PE file.\n", argv[1]);
        CloseHandle(hFile);
        free(lpFileBuffer);
        return 1;
    }
    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER) lpFileBuffer;
    PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS) (lpFileBuffer + pDosHeader->e_lfanew);
    if (pNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
        printf("Error:        File %s is not a valid PE file.\n", argv[1]);
        CloseHandle(hFile);
        free(lpFileBuffer);
        return 1;
    }

    // Step 4: Parse the IMAGE_NT_HEADERS structure to obtain the address of the IMAGE_OPTIONAL_HEADER structure
    PIMAGE_OPTIONAL_HEADER pOptionalHeader = &pNtHeaders->OptionalHeader;

    // Step 5: Parse the IMAGE_OPTIONAL_HEADER structure to obtain the addresses of the IMAGE_DIRECTORY_ENTRY_IMPORT and IMAGE_DIRECTORY_ENTRY_BASERELOC data directories
    DWORD importTableRVA = pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD importTableSize = pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) (lpFileBuffer + importTableRVA);

    DWORD relocTableRVA = pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD relocTableSize = pOptionalHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
    PIMAGE_BASE_RELOCATION pBaseRelocation = (PIMAGE_BASE_RELOCATION) (lpFileBuffer + relocTableRVA);

    // Step 6: Parse the IMAGE_FILE_HEADER structure to obtain the number of sections in the file
    PIMAGE_FILE_HEADER pFileHeader = &pNtHeaders->FileHeader;
    WORD numSections = pFileHeader->NumberOfSections;

    // Step 7: Iterate over each section in the file, and parse the IMAGE_SECTION_HEADER structure for each section to obtain information about the section
    PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER) (lpFileBuffer + pDosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS));
    for (WORD i = 0; i < numSections; i++) {
        printf("Section %d\n", i + 1);
        printf("\tName: %.*s\n", IMAGE_SIZEOF_SHORT_NAME, pSectionHeader->Name);
        printf("\tVirtual Address: 0x%08X\n", pSectionHeader->VirtualAddress);
        printf("\tVirtual Size: 0x%08X\n", pSectionHeader->Misc.VirtualSize);
        printf("\tRaw Size: 0x%08X\n", pSectionHeader->SizeOfRawData);
        printf("\tRaw Data Pointer: 0x%08X\n", pSectionHeader->PointerToRawData);
        printf("\tCharacteristics: 0x%08X\n", pSectionHeader->Characteristics);
        pSectionHeader++;
    }

    // Step 8: For the IMAGE_DIRECTORY_ENTRY_IMPORT data directory, iterate over each import descriptor in the import address table,
    // and parse the IMAGE_IMPORT_DESCRIPTOR structure for each descriptor to obtain information about the imported DLL and the functions imported from it.
    while (pImportDescriptor->OriginalFirstThunk != 0) {
        PIMAGE_THUNK_DATA pThunkData = (PIMAGE_THUNK_DATA) (lpFileBuffer + pImportDescriptor->OriginalFirstThunk);
        PIMAGE_THUNK_DATA pThunkDataIAT = (PIMAGE_THUNK_DATA) (lpFileBuffer + pImportDescriptor->FirstThunk);
        PIMAGE_IMPORT_BY_NAME pImportByName = NULL;
        HMODULE hModule = LoadLibraryA((LPCSTR) (lpFileBuffer + pImportDescriptor->Name));

        printf("Imported DLL: %s\n", lpFileBuffer + pImportDescriptor->Name);
        while (pThunkData->u1.AddressOfData != 0) {
                       if (IMAGE_SNAP_BY_ORDINAL(pThunkData->u1.Ordinal)) {
                printf("\tOrdinal: 0x%08X\n", IMAGE_ORDINAL(pThunkData->u1.Ordinal));
            } else {
                pImportByName = (PIMAGE_IMPORT_BY_NAME) (lpFileBuffer + pThunkData->u1.AddressOfData);
                printf("\tFunction Name: %s\n", pImportByName->Name);
            }
            pThunkData++;
            pThunkDataIAT++;
        }
        FreeLibrary(hModule);
        pImportDescriptor++;
    }

    // Step 9: For the IMAGE_DIRECTORY_ENTRY_BASERELOC data directory, iterate over each block of base relocations in the block of memory,
    // and parse the IMAGE_BASE_RELOCATION structure for each block to obtain information about the relocations in the block.
    while (relocTableSize > 0) {
        DWORD blockSize = pBaseRelocation->SizeOfBlock;
        DWORD numRelocations = (blockSize - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        PWORD pRelocationData = (PWORD) ((LPBYTE) pBaseRelocation + sizeof(IMAGE_BASE_RELOCATION));

        printf("Base Relocation Block:\n");
        printf("\tVirtual Address: 0x%08X\n", pBaseRelocation->VirtualAddress);
        printf("\tSize of Block: 0x%08X\n", pBaseRelocation->SizeOfBlock);
        while (numRelocations--) {
            WORD relocationOffset = *pRelocationData & 0xFFF;
            WORD relocationType = *pRelocationData >> 12;
            DWORD relocationAddress = pBaseRelocation->VirtualAddress + relocationOffset;

            switch (relocationType) {
                case IMAGE_REL_BASED_ABSOLUTE:
                    break;
                case IMAGE_REL_BASED_HIGH:
                    printf("\t\tHIGH: 0x%08X\n", relocationAddress);
                    break;
                case IMAGE_REL_BASED_LOW:
                    printf("\t\tLOW: 0x%08X\n", relocationAddress);
                    break;
                case IMAGE_REL_BASED_HIGHLOW:
                    printf("\t\tHIGHLOW: 0x%08X\n", relocationAddress);
                    break;
                case IMAGE_REL_BASED_DIR64:
                    printf("\t\tDIR64: 0x%08X\n", relocationAddress);
                    break;
                default:
                    printf("\t\tUnknown relocation type: %d\n", relocationType);
                    break;
            }
            pRelocationData++;
        }
        relocTableSize -= blockSize;
        pBaseRelocation = (PIMAGE_BASE_RELOCATION) ((LPBYTE) pBaseRelocation + blockSize);
    }

    // Step 10: Cleanup
    CloseHandle(hFile);
    free(lpFileBuffer);
    return 0;
}


