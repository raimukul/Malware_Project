import angr
import archinfo

proj = angr.Project("D:\Projects\Malware_Project\Project 01\Stardust.EXE")

print('Part one output below')
print()
print(proj.arch)
print(proj.entry)
print(proj.filename)
print(proj.arch.bits)
print(proj.arch.name)
print(proj.arch.memory_endness)
print()
print('Part two output below')
print()
# loader
print(proj.loader)
print(proj.loader.shared_objects)
print(proj.loader.min_addr)
print(proj.loader.max_addr)
print(proj.loader.main_object)
print(
    proj.loader.main_object.execstack
)  # sample query: does this binary have an executable stack?
print(proj.loader.main_object.pic)  # sample query: is this binary position-independent?
print(proj.loader.all_objects)
print(proj.loader.all_pe_objects)

print()
print('Part three output below')
print()
print()
print(proj.loader)
print(proj.loader.shared_objects)
print(proj.loader.min_addr)
print(proj.loader.max_addr)
print(proj.loader.main_object)
print(
    proj.loader.main_object.execstack
)  # sample query: does this binary have an executable stack?
print(proj.loader.main_object.pic)  # sample query: is this binary position-independent?
print(proj.loader.all_objects)
print(proj.loader.all_pe_objects)
print()
print('Part four output below')
print()
print()
# loader
print (proj.loader)
print(proj.loader.shared_objects)
print(proj.loader.min_addr)
print(proj.loader.max_addr)
print(proj.loader.main_object)
print(proj.loader.main_object.execstack) # sample query: does this binary have an executable stack?
print(proj.loader.main_object.pic) # sample query: is this binary position-independent?
print(proj.loader.all_objects)
print(proj.loader.all_pe_objects)
print()
print('Part 5 output below')
print()
print()
print(proj.loader.main_object.segments)
print(proj.loader.main_object.sections)
print(proj.loader.main_object.find_segment_containing(proj.loader.main_object.entry))
print(proj.loader.main_object.find_section_containing(proj.loader.main_object.entry))
print()
print('Part 6 output below')
print()
print()
print(proj.loader.main_object.imports['CloseHandle']) # Get the import address for a symbol

print("rebased_addr", proj.loader.main_object.imports['CloseHandle'].rebased_addr) 

closeHandle = proj.loader.find_symbol('CloseHandle')

print(closeHandle)

print(closeHandle.name)

print(closeHandle.owner)

print(hex(closeHandle.rebased_addr))

print (hex (closeHandle.linked_addr))

print (hex (closeHandle.relative_addr))
print(hex(proj.loader.main_object.linked_base))
print()
print('Part 7 output below')
print()
print(hex(proj.loader.main_object.mapped_base))
print(closeHandle.is_export)
print(closeHandle.is_import)

# On Loader, the method is find_symbol because it performs a search operation to find the symbol.

# On an individual object, the method is get_symbol because there can only be one symbol with a given name

main_symbols = proj.loader.main_object.symbols

print (main_symbols)

main_clHandle = proj.loader.main_object.imports["CloseHandle"]
print("main_clHandle is export?", main_clHandle.symbol.is_export)
print("main_clHandle is import?", main_clHandle.symbol.is_import)
print(main_clHandle.symbol.resolvedby)
print(proj.loader.main_object.imports)

print (proj.loader.shared_objects['kernel32.dll'].imports)
# Simulation Procedures
print()
print('Part 8 output below')
print()
stub_func = angr.SIM_PROCEDURES['stubs']['ReturnUnconstrained'] # this is a CLASS
proj.hook(0x10000, stub_func()) # hook with an instance of the class

print(proj.is_hooked(0x10000))
print(proj.hooked_by(0x10000))
print(proj.unhook(0x16000))

@proj.hook(0x20000, length=5)
def my_hook(state):
  state.regs.rax = 1
print(proj.is_hooked(0x20000))

# Solver Engine
print()
print('Part 9 output below')
print()
state = proj.factory.entry_state()

one = state.solver.BVV(1, 64)
print(one)

one_hundred = state.solver.BVV(100, 64)
print(one_hundred)

weird_nine = state.solver.BVV(9, 27)
print (weird_nine)

print(one + one_hundred)
print(one_hundred + 0x100)
print(one_hundred - 0x200)
weird_nine.zero_extend(64 - 27)
print(one + weird_nine.zero_extend(64 - 27))

print()
print('Part 10 output below')
print()
x = state.solver.BVS("x", 64)
y = state.solver.BVS("y", 64)

print(x + y)

print(x + one)

print((x + one) / 2)

print(x - y)

tree = (x +1) / (y + 2)
print(tree)

print(tree.op)
print(tree.args)

print (tree.args[0].op)
print(tree.args[0].args)
print(tree.args[0].args[1].op)
print(tree.args[0].args[1].args)
print()
print('Part 11 output below')
print()
print(x == 1)

print (x==one)

print (x>2)

print(x+y == one_hundred+5)
print (one_hundred > 5)
print(one_hundred > -5)

yes = one == 1
no = one == 2
maybe = x == y

print(state.solver.is_true(yes))
print(state.solver.is_false(yes))
print(state.solver.is_true(no))
print(state.solver.is_false(no))
print(state.solver.is_true(maybe))
print(state.solver.is_false(maybe))


state.solver.add(x > y)
state.solver.add(y > 2)
state.solver.add(10 > x)
print(state.solver.eval(x))

state = proj.factory.entry_state()# get a fresh state without constraints
input = state.solver.BVS('input', 64)

operation = (((input + 4) * 3) >> 1) + input
output = 200

state.solver.add(operation == output)
print(state.solver.eval(input))
state.solver.add(input < 2**32)
print(state.satisfiable())


# fresh state
print()
print('Part 12 output below')
print()
state = proj.factory.entry_state()
state.solver.add(x - y >= 4)
state.solver.add(y > 0)
print(state.solver.eval(x))
print(state.solver.eval(y))
print(state.solver.eval(x + y))


# Floating point numbers



#fresh state
print()
print('Part 13 output below')
print()
state = proj.factory.entry_state()

a = state.solver.FPV(3.2, state.solver.fp.FSORT_DOUBLE)
print(a)

b = state.solver.FPS('b', state.solver.fp.FSORT_DOUBLE)
print (b)

print (a+b)

print(a+4.4)

print(b+2 < 0)

state.solver.add(b + 2 < 0)

state.solver.add(b+2>-1)

print(state.solver.eval(b))

print(a.raw_to_bv())

print(b.raw_to_bv())

print(state.solver.BVV(0, 64).raw_to_fp())
print(state.solver.BVS('x', 64).raw_to_fp())

print (a.val_to_bv(12))
print(a.val_to_bv(12).val_to_fp(state.solver.fp.FSORT_FLOAT))

# SimState
print()
print('Part 14 output below')
print()
state = proj.factory.entry_state()
print(state.regs.rip)
print(state.regs.eax)
print(state.mem[proj.entry].int.resolved) # interpret the memory at the entry point as a C int)
bv = state.solver.BVV(0x1234, 32)
print (bv)
ev = state.solver.eval(bv)
print(ev)
state.regs.esi = state.solver.BVV(3, 64)
print(state.regs.esi)
state.mem[0x1000].long = 4
print(state.mem[0x1060].long.resolved)

#copy rsp to rbp
state.regs.rbp = state.regs.rsp

#store rdx to memory at 0x1000
state.mem[0x1000].uint64_t = state.regs.rdx

#eereference rbp

state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved
#add rax, qword ptr [rsp+8]

state.regs.rax += state.mem[state.regs.rsp+8].uint64_t.resolved

state = proj.factory.entry_state(stdin=angr.SimFile)

while True:
    succ = state.step()
    if len(succ.successors) == 2:
        break
    state = succ.successors[0]

state1, state2 = succ.successors
print(state1)
print(state2)

input_data = state1.posix.stdin.load(0, state1.posix.stdin.size)
print(input_data, state1.posix.stdin.size)
print("input_data", state1.solver.eval(input_data, cast_to=bytes))
 

 #store and load can also be used for registers
print()
print('Part 15 output below')
print()
s = proj.factory.blank_state()

s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))
print(s.memory.load(0x4004, 6))

print (s.memory.load(0x4000, 4, endness=archinfo.Endness.LE))